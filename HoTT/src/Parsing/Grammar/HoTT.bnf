// Deductive system

// Judgments
@ <judgment> ::= <context> "deduce" <term> "oftype" <term>       -- typing
    | <context> "deduce" <term> "eq_judg" <term> "oftype" <term> -- definitional_equality
    | <context> "deduce" <term> "reduc" <term>              -- reduction
    | <context> "ctx"                       -- valid_context

// Contexts
@ <context> ::= "empty_context"             -- empty_context
   | <context> "," <var_decl>               -- extended_context
   | <context> "," <var_def>                -- definition_context

@ <var_decl> ::= <var> "oftype" <term>
@ <var_def> ::= <var> "vdef" <term> "oftype" <term>

// Recursion/induction
@ <motives> ::= "{" <motiveslist> "}"
@ <motiveslist> ::= <motive> | <motiveslist> ";" <motive>
@ <motive> ::= <var> "oftype" <term> "to" <term>
@ <clauses> ::= "[" <clauselist> "]"
@ <clauselist> ::= <clause> | <clauselist> <clause>
@ <clause> ::= "or" <pattern> "to" <term>
@ <pattern> ::= <CNAME> | <CNAME> <varlist>
@ <varlist> ::= <var> | <varlist> <var>

// Inductive types
@ <params> ::= <var_decl> | <params> <var_decl>
@ <constructors> ::= <constructor> | <constructor> "or" <constructor>
@ <constructor> ::= <CNAME> <var_decl_list> ":" <term>
@ <var_decl_list> ::= <var_decl> | <var_decl_list> <var_decl>


// HoTT

// Terms
@ <term> ::=
    | <universe>                            -- Universes
    | <var>                                 -- vars
    // Formation rules
    | "empty_type"                          -- 0-formation
    | "unit_type"                           -- 1-formation
    | "pi" <var_decl> "." <term>            -- Π-formation
    | "sigma" <var_decl> "." <term>         -- Σ-formation
    | <term> "+" <term>                     -- coproduct-formation
    | "Id" "(" <term> "," <term> "," <term>")"              -- id-formation
    | "Ind" <name> <params> "where" <constructors>          -- inductive_formation
    // Introduction rules
    | "star" ":" "unit_type"                -- 1-intro
    | "lambda" <var_decl> "." <term>        -- lambda-intro
    | "(" <term> "," <term> ")"             -- pair-intro
    | "inl" <term> | "inr" <term>           -- coproduct-intro
    | "refl" "(" <term> ")"                 -- refl-intro
    | <constructor>                         -- constructor-intro
    // Elimination rules
    | "absurd" <term>                       -- 0-elimination
    | <term> "(" <term> ")"                 -- application
    | "case" <term> "of" "inl" <var> "to" <term>            -- coproduct elimination left
    | "case" <term> "of" "inr" <var> "to" <term>            -- coproduct elimination right
    | "proj_1" <term> | "proj_2" <term>     -- Σ-elimination
    | "J" "(" <term> "," <term> "," <term> ")"              -- path induction
    | "rec" <term> <motives> <clauses>      -- recursion
    | "ind" "(" <term> "," <clauses> ")"    -- induction
    // Computation
    | "let" "(" <var> "," <var> ")" "=" <term> "in" <term>  -- Σ-elimination (pattern matching)


// 'Infrastructure'
@ <universe> ::= "Type" | "Type_" <NUMBER>  -- Hierarchy of universes
@ <var> ::= <VNAME>                         -- variable names

@ <NUMBER> ::= /[0-9]+/
@ <VNAME> ::= /var_[a-zA-Z_]+(_[0-9]+)?/
@ <CNAME> ::= /[a-zA-Z_][a-zA-Z0-9_]*/
