// ----------------------------------------------------------------------------- Deductive system

@ <inference_system> ::= <rule>*

@ <rule> ::= <rule_name> ":" <inference_rule>
@ <rule_name> ::= <RULE_NAME>

@ <inference_rule> ::= <premises> "—————" <conclusion>

@ <premises> ::= <judgment_list>
    | <EMPTY_PREMISE>

@ <conclusion> ::= <judgment_list>

@ <side_condition> ::= <var_decl> "in" <context>
    | <VNAME> "not in" "dom(" <context> ")"
    | <VNAME> "fresh"


// judgments
@ <judgment> ::= <context> "ctx"                  -- valid_context
    | <context> "⊢" <term> ":" <term>             -- typing
    | <context> "⊢" <term> "\equiv" <term> ":" <term>     -- definitional_equality
    | <context> "⊢" <term> "reduc" <term>                  -- reduction
    | <side_condition>                             -- meta-level conditions
 
@ <judgment_list> ::= <judgment> ( ",\quad" <judgment>)*

// contexts
@ <context> ::= <EMPTY_CTX>                 -- empty_context
   | <CTX_NAME>                             -- context name
   | <context> "," <var_decl>               -- extended_context
   | <context> "," <var_def>                -- definition_context

@ <var_decl> ::= <var> ":" <term> | "(" <var> ":" <term> ")"
@ <var_decl_list> ::= <var_decl> ("," <var_decl>)*
@ <var_def> ::= <var> "vdef" <term> ":" <term>

// motives for recursion/induction
@ <pattern> ::= <CNAME> | <CNAME> <varlist>
@ <clause> ::= "begclause" <pattern> "to" <term>
@ <clauses> ::= "[[" (<clause>)+ "]]"
@ <motive> ::= <var> ":" <term> "to" <term>
@ <motives> ::= "{" <motive> (";" <motive>)* "}"

// Inductive types
@ <params> ::= "(" <var_decl_list> ")"
@ <constructor> ::= <CNAME> (<params>)? ":" <term>
@ <constructors> ::= ("|" <constructor>)+


// ----------------------------------------------------------------------------- HoTT

// the following rules are not axioms, it's only the needed for the syntax for the axioms
// for example, to introduce the axioms for induction, we need to allow the syntax "ind(...)"

// Formation rules
@ <formation_empty> ::= "empty_type"                        -- 0-formation
@ <formation_unit> ::= "unit_type"                          -- 1-formation
@ <formation_arrow> ::= <term> "\\to" <term>                -- arrow-formation
@ <formation_pi> ::= "\Pi_{" <var_decl> "}" <term>          -- Π-formation
@ <formation_sigma> ::= "sigma" <var_decl> "." <term>       -- Σ-formation
@ <formation_coproduct> ::= <term> "+" <term>               -- coproduct-formation
@ <formation_id> ::= "Id" <subscript>? "(" <term> "," <term> "," <term>")"                 -- id-formation
@ <formation_induction> ::= "Ind" <CNAME> <params> ":" <term> "where" <constructors>       -- inductive_formation

@ <formation_rule> ::= <formation_empty> | <formation_unit> | <formation_arrow> | <formation_pi> 
    | <formation_sigma> | <formation_coproduct> 
    | <formation_id> | <formation_induction>

// Introduction rules
@ <intro_unit> ::= <STAR> ":" "unit_type"                -- 1-intro
@ <intro_lambda> ::= "\lambda" <var_decl> "." <term>     -- lambda-intro
@ <intro_pair> ::= "(" <term> "," <term> ")"             -- pair-intro
@ <intro_coproduct> ::= "inl" "(" <term> ")" | "inr" "(" <term> ")"     -- coproduct-intro
@ <intro_refl> ::= "refl" "(" <term> ")"                 -- refl-intro
@ <intro_constr> ::= <constructor>                       -- constructor-intro

@ <introduction_rule> ::= <intro_unit> | <intro_lambda> | <intro_pair> | <intro_coproduct> | <intro_refl> | <intro_constr>


// Elimination rules
@ <elim_empty> ::= "absurd" <term>                     -- 0-elimination
@ <elim_unit> ::= "elimT" "(" <term> "," <term> ")"    -- 1-elimination
@ <elim_apply> ::= <term> "%(" <term> ")"              -- application
@ <elim_coprod_left> ::= <var> "to" <term>             -- coproduct elimination left
@ <elim_coprod_right> ::= <var> "to" <term>            -- coproduct elimination right
@ <elim_coprod> ::= "case" <term> "of" "inl" <elim_coprod_left> "|" "inr" <elim_coprod_right>
@ <elim_sigma1> ::= "pr1" "(" <term> ")"               -- Σ1
@ <elim_sigma2> ::= "pr2" "(" <term> ")"               -- Σ2
@ <elim_sigma> ::= <elim_sigma1> | <elim_sigma2>       -- Σ-elimination
@ <path_induction> ::= "J" "(" <term> "," <term> "," <term> "," <term> "," <term> "," <term> ")"      -- path induction
// J(A, a, C, d, b, p) where:
//   A: type, a:A, C: Π (b:A). Π (p:Id_A(a,b)). Type, d: C(a, refl_a), b:A, p:Id_A(a,b)

@ <recursion> ::= "rec" "(" <term> "," <term> "," <term> "," <term> ")"     -- recursion
@ <induction> ::= "ind" "(" <term> "," <term> "," <term> "," <term> ")"     -- induction
// rec(A, R, F, a) where:
//   A: Type
//   R: A → A → Type (well-founded relation)
//   F: Π(x:A). (Π(y:A). R(y, x) → B(y)) → B(x)
//   a: A
// Result: B(a)

@ <elimination_rule> ::= <elim_empty> | <elim_unit> | <elim_apply> | <elim_coprod> | <elim_sigma> 
    | <path_induction> | <recursion> | <induction>


// Computation
@ <computation_rule> ::= "\\text{let}" <term> "=" <term> "\\text{in}" <term>
// all computation rules are 'factorized' into a single 'binding' rule for easier usage

// Terms
@ <term> ::= <universe>
    | <var>
    | <var> "(" <term> ")"                              -- for example : var_f(var_A)
    | <STAR>
    | <formation_rule>
    | <introduction_rule>
    | <elimination_rule>
    | <computation_rule>
    | <CNAME> ( "(" <term> ")" )?                       -- for example : List(var_A)
    | "(" <term> ")"

@ <subscript> ::= "[" term "]"


// ----------------------------------------------------------------------------- 'Infrastructure'

@ <universe> ::= "Type" | "Type_i" | "Type_{i}" | "Type_{i+1}" | "Type_" <NUMBER>  -- Hierarchy of universes
@ <var> ::= <VNAME>                         -- variable names
@ <varlist> ::= <var> ("," <var>)*

@ <STAR> ::= "star"
@ <NUMBER> ::= /[0-9]+/                                 -- we allow 0109 for example
@ <VNAME> ::= /var_[a-zA-Z0-9_\\]+/ | /var_{[a-zA-Z0-9_\\\(\)]+}/
@ <CNAME> ::= /name_[a-zA-Z_\\][a-zA-Z0-9_\\]*/ | /name_{[a-zA-Z_\\][a-zA-Z0-9_\\]*}/

@ <EMPTY_CTX> ::= /empty_context/
@ <EMPTY_PREMISE> ::= /\\epsilon/
@ <CTX_NAME> ::= /context_[a-zA-Z_\\][a-zA-Z0-9_\\]*/ | /context_{[a-zA-Z_\\][a-zA-Z0-9_\\]*}/
@ <RULE_NAME> ::= /rule_[a-zA-Z_\\][a-zA-Z0-9_\\\-]*/ | /rule_{[a-zA-Z_\\][a-zA-Z0-9_\\\-]*}/
