// ----------------------------------------------------------------------------- Deductive system

// Judgments
@ <judgment> ::= <context> "ctx"                       -- valid_context
    | <context> "deduce" <term> "oftype" <term>        -- typing
    | <context> "deduce" <term> "eq_judg" <term> "oftype" <term> -- definitional_equality
    | <context> "deduce" <term> "reduc" <term>                   -- reduction
 
// Contexts
@ <context> ::= EMPTY_CTX                   -- empty_context
   | <context> "," <var_decl>               -- extended_context
   | <context> "," <var_def>                -- definition_context

@ <var_decl> ::= <var> "oftype" <term>
@ <var_decl_list> ::= <var_decl> | <var_decl_list> "," <var_decl>
@ <var_def> ::= <var> "vdef" <term> "oftype" <term>

// Recursion/induction
@ <motives> ::= "{" <motiveslist> "}"
@ <motiveslist> ::= <motive> | <motiveslist> ";" <motive>
@ <motive> ::= <var> "oftype" <term> "to" <term>
@ <clauses> ::= "[" <clauselist> "]"
@ <clauselist> ::= <clause> | <clauselist> <clause>
@ <clause> ::= "or" <pattern> "to" <term>
@ <pattern> ::= <CNAME> | <CNAME> <varlist>

// Inductive types
@ <params> ::= <var_decl> | <params> <var_decl>
@ <constructors> ::= <constructor> | <constructor> "or" <constructor>
@ <constructor> ::= <CNAME> <var_decl_list> ":" <term>


// ----------------------------------------------------------------------------- HoTT


// Formation rules
@ <formation_empty> ::= "empty_type"                        -- 0-formation
@ <formation_unit> ::= "unit_type"                          -- 1-formation
@ <formation_pi> ::= "pi" <var_decl> "." <term>             -- Π-formation
@ <formation_sigma> ::= "sigma" <var_decl> "." <term>       -- Σ-formation
@ <formation_coproduct> ::= <term> "+" <term>               -- coproduct-formation
@ <formation_id> ::= "Id" "(" <term> "," <term> "," <term>")"                   -- id-formation
@ <formation_induction> ::= "Ind" <CNAME> <params> "where" <constructors>       -- inductive_formation

@ <formation_rule> ::= <formation_empty> | <formation_unit> | <formation_pi> | <formation_sigma> | <formation_coproduct> 
    | <formation_id> | <formation_induction>


// Introduction rules
@ <intro_unit> ::= "star" ":" "unit_type"                -- 1-intro
@ <intro_lambda> ::= "lambda" <var_decl> "." <term>      -- lambda-intro
@ <intro_pair> ::= "(" <term> "," <term> ")"             -- pair-intro
@ <intro_coproduct> ::= "inl" <term> | "inr" <term>      -- coproduct-intro
@ <intro_refl> ::= "refl" "(" <term> ")"                 -- refl-intro
@ <intro_constr> ::= <constructor>                       -- constructor-intro

@ <introduction_rule> ::= <intro_unit> | <intro_lambda> | <intro_pair> | <intro_coproduct> | <intro_refl> | <intro_constr>


// Elimination rules
@ <elim_empty> ::= "absurd" <term>                      -- 0-elimination
@ <elim_apply> ::= <term> "(" <term> ")"                -- application
@ <elim_coprod_left> ::= "case" <term> "of" "inl" <var> "to" <term>            -- coproduct elimination left
@ <elim_coprod_right> ::= "case" <term> "of" "inr" <var> "to" <term>           -- coproduct elimination right
@ <elim_sigma> ::= "proj_1" <term> | "proj_2" <term>    -- Σ-elimination
@ <path_induction> ::= "J" "(" <term> "," <term> "," <term> ")"                -- path induction
@ <recursion> ::= "rec" <term> <motives> <clauses>      -- recursion
@ <induction> ::= "ind" "(" <term> "," <clauses> ")"    -- induction

@ <elimination_rule> ::= <elim_empty> | <elim_apply> | <elim_coprod_left> | <elim_coprod_right> | <elim_sigma> 
    | <path_induction> | <recursion> | <induction>


// Computation
@ <computation_rule> ::= "let" <var_def> "in" <term>

// Terms
@ <term> ::= <universe>
    | <var>
//    | <formation_rule>
//    | <introduction_rule>
//    | <elimination_rule>
//    | <computation_rule>


// ----------------------------------------------------------------------------- 'Infrastructure'

@ <universe> ::= "Type" | "Type_" <NUMBER>  -- Hierarchy of universes
@ <var> ::= <VNAME>                         -- variable names
@ <varlist> ::= <var> | <varlist> "," <var>

@ <NUMBER> ::= /[0-9]+/                                 -- we allow 0109 for example
@ <VNAME> ::= /var_[a-zA-Z0-9_]+/
@ <CNAME> ::= /[a-zA-Z_][a-zA-Z0-9_]*/

@ <EMPTY_CTX> ::= /empty_context/
